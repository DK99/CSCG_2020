# First thoughts:
The program expects 2 user inputs. After looking at the provided source code I saw that the inputs are provided via a `gets` and all the text is printed via `printf`. So here is a possible BufferOverflow because gets doesn't check the buffer size provided and writes however long the input is to the stack.  Because of the `printf ` it is feasible to use a StringFormatExploit.
The last step is to get a shell, Luckily the function `WINgardium_leviosa` is provided which calls the shell.
With the program checksec I also noticed that there are no stack canaries.

# The Exploit:
First I created a small python script with pwntools. The script would start the program and wait for the string `Enter your witch name:`  after that the program expects a user input. So the script would send a string containing `%p` 42 times and between a `|`. Because I knew from the source that the given witch name would be printed directly with `printf`. I knew that if I send `%p` the program would leak the next 42 addresses from the stack. Now I attach gdb to the program and with the command `vmmap` I see at which address my program starts and ends. If I now compare this with the output I got from my input. I notice that the 38th value is inside my programs address space (e.g. 0x561e3b1b3b21). With this knowledge I can now defeat ASLR normally this randomizes the addresses at which the program and its libraries get loaded. But now I can get an address from inside the programs address space and because the methods inside the program have a constant relative address I now searches for the `WINgardium_leviosa` function and copied the address (e.g. 0x561e3b1b39ec). So the distance between is 0x561e3b1b3b21-0x561e3b1b39ec=0x135, so I know if I add 0x135 to the 38th value I get the start of the `WINgardium_leviosa` function.
Now I need to know where the `AAAAAA` functions return pointer is located. To get this I rewrite my python script so it waits for the string `enter your magic spell:` and then it sends `Expelliarmus\x00` concatenated with `cyclic(0xff)`. I first need to send `Expelliarmus` because in the source I can see that if the input doesn't match it then the program just exits and because strings are null terminated I send a null byte with it. After that I send a sequence of chars generated by pwntools. This sequence is special as every part can be recognized by only 4 chars. Now starting the script attaching gdb and waiting. There is a Segmentation Fault. But I also see that the program tried to jump to an address which starts with the chars `cnaa`. So now I know if I replace `cyclic(0xff)` by `"A"*cyclic_find("cnaa")` then the next thing overwrites the return address. Here I now could write the address of the `WINgardium_leviosa` functions start.
But because of the BufferOverflow the stack got unaligned. To align it I just need to make a simple return in front of that. So I have to get an address to a return e.g. the return address of the  `WINgardium_leviosa` function is 0x561e3b1b3a22 and calculate the distance to the start of the `WINgardium_leviosa` function (0x561e3b1b39ec-0x561e3b1b3a22=0x36).
Now I can create the final payload. First `"Expelliarmus\x00"` then the padding `"A"*cyclic_find("cnaa")` after that the address to the return and after that the start address of the `WINgardium_leviosa` function.
At the end the script looks like this:
```
from pwn import *

p = process("./pwn1")
#p = remote("hax1.allesctf.net", 9100)
FORMATSTRING = "|".join(["%p" for _ in xrange(0,42)])
MAIN_TO_WIN_OFFEST = 0x135

p.recvuntil("Enter your witch name:")
p.sendline(FORMATSTRING)

LEAKS = p.recvuntil("enter your magic spell:").split("|")
MAIN = int(LEAKS[-4], 16)

log.info("Leaked return value 0x{:x}".format(MAIN))
WIN = MAIN-MAIN_TO_WIN_OFFEST
RET = WIN+0x36

raw_input("attach gdb")
PADDING = "A"*cyclic_find("cnaa")
p.sendline("Expelliarmus\x00" + PADDING + p64(RET) + p64(WIN))
p.interactive()
```
Now that I got a bash just execute `cat flag` and the flag is printed out.
To get the real flag just change the attached program to the server and execute.

# Prevention:
The problem is that there are no Canary Values and that the user input is not sanitized.
If there where Canary Values the exploit would be harder. If the input got sanitized and a safe alternative for `gets` would be used like `fgets` then it wouldn't be possible to overwrite the return value.
